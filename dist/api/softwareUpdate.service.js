"use strict";
/**
 * REST API for Flexicore filtered by your access rights
 * Flexicore REST API
 *
 * OpenAPI spec version: V1.1.0
 * Contact: avishaybennatan@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-unused-variable member-ordering */
const core_1 = require("@angular/core");
const flexiCoreDecycle_1 = require("./flexiCoreDecycle");
const http_1 = require("@angular/http");
const http_2 = require("@angular/http");
const variables_1 = require("../variables");
const configuration_1 = require("../configuration");
let SoftwareUpdateService = class SoftwareUpdateService {
    constructor(http, basePath, configuration) {
        this.http = http;
        this.basePath = 'https://192.168.0.41:8080/FlexiCore/rest';
        this.defaultHeaders = new http_1.Headers();
        this.configuration = new configuration_1.Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     *
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    extendObj(objA, objB) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    activateDevice(id, authenticationKey, extraHttpRequestParams) {
        return this.activateDeviceWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param fileResourceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    addDeviceInitiatedLog(deviceId, fileResourceId, authenticationKey, extraHttpRequestParams) {
        return this.addDeviceInitiatedLogWithHttpInfo(deviceId, fileResourceId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param updateFileId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice
     * @param keepOriginal
     * @param name
     * @param shouldExtract
     * @param deleteAfterExtract
     * @param interval
     * @param startMilis
     */
    attachDeviceToFileUpdate(deviceId, updateFileId, authenticationKey, locationOnDevice, keepOriginal, name, shouldExtract, deleteAfterExtract, interval, startMilis, extraHttpRequestParams) {
        return this.attachDeviceToFileUpdateWithHttpInfo(deviceId, updateFileId, authenticationKey, locationOnDevice, keepOriginal, name, shouldExtract, deleteAfterExtract, interval, startMilis, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param lat
     * @param lon
     * @param serialNumber
     */
    checkDeviceActivatedAndUpdateLocation(id, authenticationKey, lat, lon, serialNumber, extraHttpRequestParams) {
        return this.checkDeviceActivatedAndUpdateLocationWithHttpInfo(id, authenticationKey, lat, lon, serialNumber, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    checkFoLogRequests(deviceId, authenticationKey, extraHttpRequestParams) {
        return this.checkFoLogRequestsWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearDeviceUpdateLinks(deviceId, authenticationKey, extraHttpRequestParams) {
        return this.clearDeviceUpdateLinksWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearFileUpdates(id, authenticationKey, extraHttpRequestParams) {
        return this.clearFileUpdatesWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearLogs(id, authenticationKey, extraHttpRequestParams) {
        return this.clearLogsWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearUpdateLink(linkId, authenticationKey, extraHttpRequestParams) {
        return this.clearUpdateLinkWithHttpInfo(linkId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param fileUpdateId
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    closeFetchRequest(fileUpdateId, linkId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        return this.closeFetchRequestWithHttpInfo(fileUpdateId, linkId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    closeRequest(linkId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        return this.closeRequestWithHttpInfo(linkId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    confirmRestart(linkId, authenticationKey, extraHttpRequestParams) {
        return this.confirmRestartWithHttpInfo(linkId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param bundleName
     */
    createUpdateBundle(authenticationKey, body, bundleName, extraHttpRequestParams) {
        return this.createUpdateBundleWithHttpInfo(authenticationKey, body, bundleName, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    deactivateDevice(id, authenticationKey, extraHttpRequestParams) {
        return this.deactivateDeviceWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    exportUpdates(authenticationKey, body, extraHttpRequestParams) {
        return this.exportUpdatesWithHttpInfo(authenticationKey, body, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    fixDevicesDevices(authenticationKey, extraHttpRequestParams) {
        return this.fixDevicesDevicesWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    fixDevicesName(authenticationKey, extraHttpRequestParams) {
        return this.fixDevicesNameWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    fixDuplicateMacs(authenticationKey, extraHttpRequestParams) {
        return this.fixDuplicateMacsWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getDuplicatedMacs(authenticationKey, extraHttpRequestParams) {
        return this.getDuplicatedMacsWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice
     * @param keepOriginal
     * @param name
     * @param generationRequest
     * @param interval
     * @param startMilis
     */
    getFileFromDeviceRequest(deviceId, authenticationKey, locationOnDevice, keepOriginal, name, generationRequest, interval, startMilis, extraHttpRequestParams) {
        return this.getFileFromDeviceRequestWithHttpInfo(deviceId, authenticationKey, locationOnDevice, keepOriginal, name, generationRequest, interval, startMilis, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    getMinimumCheckInterval(mac, authenticationKey, dateCompleted, extraHttpRequestParams) {
        return this.getMinimumCheckIntervalWithHttpInfo(mac, authenticationKey, dateCompleted, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getPendingFileUpdates(mac, authenticationKey, extraHttpRequestParams) {
        return this.getPendingFileUpdatesWithHttpInfo(mac, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate
     */
    getPeriodicFilesForFileUpdate(id, authenticationKey, startingDate, extraHttpRequestParams) {
        return this.getPeriodicFilesForFileUpdateWithHttpInfo(id, authenticationKey, startingDate, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate
     */
    getPeriodicFilesForLogRequests(id, authenticationKey, startingDate, extraHttpRequestParams) {
        return this.getPeriodicFilesForLogRequestsWithHttpInfo(id, authenticationKey, startingDate, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getRequiredUpdates(mac, authenticationKey, extraHttpRequestParams) {
        return this.getRequiredUpdatesWithHttpInfo(mac, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getSoftwareToRestart(deviceId, authenticationKey, extraHttpRequestParams) {
        return this.getSoftwareToRestartWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDeviceFileUpdates(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listDeviceFileUpdatesWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDeviceInstalledSoftwares(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listDeviceInstalledSoftwaresWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevicePendingInstallSoftwares(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listDevicePendingInstallSoftwaresWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevicePendingLogRequests(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listDevicePendingLogRequestsWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    listDeviceSettings(id, authenticationKey, extraHttpRequestParams) {
        return this.listDeviceSettingsWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param serial
     * @param mac
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevices(authenticationKey, body, serial, mac, pagesize, currentPage, extraHttpRequestParams) {
        return this.listDevicesWithHttpInfo(authenticationKey, body, serial, mac, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listFileUpdates(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listFileUpdatesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listSoftwares(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listSoftwaresWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listUpdateBundle(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listUpdateBundleWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listUpdateFiles(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        return this.listUpdateFilesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    massDownload(authenticationKey, body, extraHttpRequestParams) {
        return this.massDownloadWithHttpInfo(authenticationKey, body, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    prepareFileResourceBundle(authenticationKey, body, extraHttpRequestParams) {
        return this.prepareFileResourceBundleWithHttpInfo(authenticationKey, body, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param serialNumber
     * @param body
     */
    register(mac, authenticationKey, serialNumber, body, extraHttpRequestParams) {
        return this.registerWithHttpInfo(mac, authenticationKey, serialNumber, body, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param filter
     * @param level
     * @param interval
     * @param startMilis
     */
    requestLog(deviceId, authenticationKey, filter, level, interval, startMilis, extraHttpRequestParams) {
        return this.requestLogWithHttpInfo(deviceId, authenticationKey, filter, level, interval, startMilis, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param softwareId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    setSoftwareToRestart(deviceId, softwareId, authenticationKey, extraHttpRequestParams) {
        return this.setSoftwareToRestartWithHttpInfo(deviceId, softwareId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param serialNumber
     */
    updateDeviceStatusAndGetIsActivate(id, authenticationKey, body, serialNumber, extraHttpRequestParams) {
        return this.updateDeviceStatusAndGetIsActivateWithHttpInfo(id, authenticationKey, body, serialNumber, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param requestId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    updateFileUpdateStarted(requestId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        return this.updateFileUpdateStartedWithHttpInfo(requestId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    updateMultipleSoftware(deviceId, authenticationKey, body, extraHttpRequestParams) {
        return this.updateMultipleSoftwareWithHttpInfo(deviceId, authenticationKey, body, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param requestId
     * @param fileResourceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param logDate
     */
    updateRequestLogAsCompleted(requestId, fileResourceId, authenticationKey, logDate, extraHttpRequestParams) {
        return this.updateRequestLogAsCompletedWithHttpInfo(requestId, fileResourceId, authenticationKey, logDate, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param requestId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    updateRequestLogAsGathered(requestId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        return this.updateRequestLogAsGatheredWithHttpInfo(requestId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param softwareId
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateSoftware(softwareId, deviceId, authenticationKey, extraHttpRequestParams) {
        return this.updateSoftwareWithHttpInfo(softwareId, deviceId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param bundleId
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateSoftwareBundle(bundleId, deviceId, authenticationKey, extraHttpRequestParams) {
        return this.updateSoftwareBundleWithHttpInfo(bundleId, deviceId, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateUpdateCompleted(id, authenticationKey, extraHttpRequestParams) {
        return this.updateUpdateCompletedWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateUpdateStarted(id, authenticationKey, extraHttpRequestParams) {
        return this.updateUpdateStartedWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateUpdateVerified(id, authenticationKey, extraHttpRequestParams) {
        return this.updateUpdateVerifiedWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return flexiCoreDecycle_1.FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        });
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    activateDeviceWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/activate/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling activateDevice.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param fileResourceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    addDeviceInitiatedLogWithHttpInfo(deviceId, fileResourceId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/addDeviceInitiatedLog/${deviceId}/${fileResourceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling addDeviceInitiatedLog.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling addDeviceInitiatedLog.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param updateFileId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice
     * @param keepOriginal
     * @param name
     * @param shouldExtract
     * @param deleteAfterExtract
     * @param interval
     * @param startMilis
     */
    attachDeviceToFileUpdateWithHttpInfo(deviceId, updateFileId, authenticationKey, locationOnDevice, keepOriginal, name, shouldExtract, deleteAfterExtract, interval, startMilis, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/attachDeviceToFileUpdate/${deviceId}/${updateFileId}'
            .replace('${' + 'deviceId' + '}', String(deviceId))
            .replace('${' + 'updateFileId' + '}', String(updateFileId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachDeviceToFileUpdate.');
        }
        // verify required parameter 'updateFileId' is not null or undefined
        if (updateFileId === null || updateFileId === undefined) {
            throw new Error('Required parameter updateFileId was null or undefined when calling attachDeviceToFileUpdate.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (locationOnDevice !== undefined && locationOnDevice !== null) {
            headers.set('locationOnDevice', String(locationOnDevice));
        }
        if (keepOriginal !== undefined && keepOriginal !== null) {
            headers.set('keepOriginal', String(keepOriginal));
        }
        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }
        if (shouldExtract !== undefined && shouldExtract !== null) {
            headers.set('shouldExtract', String(shouldExtract));
        }
        if (deleteAfterExtract !== undefined && deleteAfterExtract !== null) {
            headers.set('deleteAfterExtract', String(deleteAfterExtract));
        }
        if (interval !== undefined && interval !== null) {
            headers.set('interval', String(interval));
        }
        if (startMilis !== undefined && startMilis !== null) {
            headers.set('startMilis', String(startMilis));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param lat
     * @param lon
     * @param serialNumber
     */
    checkDeviceActivatedAndUpdateLocationWithHttpInfo(id, authenticationKey, lat, lon, serialNumber, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/checkDeviceActivated/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling checkDeviceActivatedAndUpdateLocation.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (lat !== undefined && lat !== null) {
            headers.set('lat', String(lat));
        }
        if (lon !== undefined && lon !== null) {
            headers.set('lon', String(lon));
        }
        if (serialNumber !== undefined && serialNumber !== null) {
            headers.set('serialNumber', String(serialNumber));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    checkFoLogRequestsWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/checkFoLogRequests/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling checkFoLogRequests.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearDeviceUpdateLinksWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/clearDeviceUpdateLinks/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling clearDeviceUpdateLinks.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearFileUpdatesWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/clearFileUpdates/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling clearFileUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearLogsWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/clearLogs/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling clearLogs.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    clearUpdateLinkWithHttpInfo(linkId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/clearUpdateLink/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling clearUpdateLink.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param fileUpdateId
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    closeFetchRequestWithHttpInfo(fileUpdateId, linkId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/closeFetchRequest/${linkId}/${fileUpdateId}'
            .replace('${' + 'fileUpdateId' + '}', String(fileUpdateId))
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'fileUpdateId' is not null or undefined
        if (fileUpdateId === null || fileUpdateId === undefined) {
            throw new Error('Required parameter fileUpdateId was null or undefined when calling closeFetchRequest.');
        }
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling closeFetchRequest.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    closeRequestWithHttpInfo(linkId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/closeRequest/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling closeRequest.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param linkId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    confirmRestartWithHttpInfo(linkId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/confirmRestart/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling confirmRestart.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param bundleName
     */
    createUpdateBundleWithHttpInfo(authenticationKey, body, bundleName, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/createUpdateBundle';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (bundleName !== undefined && bundleName !== null) {
            headers.set('bundleName', String(bundleName));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    deactivateDeviceWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/deactivate/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deactivateDevice.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    exportUpdatesWithHttpInfo(authenticationKey, body, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/exportUpdates';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    fixDevicesDevicesWithHttpInfo(authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/fixDevicesDevices';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    fixDevicesNameWithHttpInfo(authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/fixDevicesName';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    fixDuplicateMacsWithHttpInfo(authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/fixDuplicateMacs';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getDuplicatedMacsWithHttpInfo(authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getDuplicatedMacs';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice
     * @param keepOriginal
     * @param name
     * @param generationRequest
     * @param interval
     * @param startMilis
     */
    getFileFromDeviceRequestWithHttpInfo(deviceId, authenticationKey, locationOnDevice, keepOriginal, name, generationRequest, interval, startMilis, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getFileFromDeviceRequest/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getFileFromDeviceRequest.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (locationOnDevice !== undefined && locationOnDevice !== null) {
            headers.set('locationOnDevice', String(locationOnDevice));
        }
        if (keepOriginal !== undefined && keepOriginal !== null) {
            headers.set('keepOriginal', String(keepOriginal));
        }
        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }
        if (generationRequest !== undefined && generationRequest !== null) {
            headers.set('generationRequest', String(generationRequest));
        }
        if (interval !== undefined && interval !== null) {
            headers.set('interval', String(interval));
        }
        if (startMilis !== undefined && startMilis !== null) {
            headers.set('startMilis', String(startMilis));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    getMinimumCheckIntervalWithHttpInfo(mac, authenticationKey, dateCompleted, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getMinimumCheckInterval/${mac}'
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getMinimumCheckInterval.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getPendingFileUpdatesWithHttpInfo(mac, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getPendingFileUpdates/${mac}'
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getPendingFileUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate
     */
    getPeriodicFilesForFileUpdateWithHttpInfo(id, authenticationKey, startingDate, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getPeriodicFilesForFileUpdate/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPeriodicFilesForFileUpdate.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (startingDate !== undefined && startingDate !== null) {
            headers.set('startingDate', String(startingDate));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate
     */
    getPeriodicFilesForLogRequestsWithHttpInfo(id, authenticationKey, startingDate, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getPeriodicFilesForLogRequests/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPeriodicFilesForLogRequests.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (startingDate !== undefined && startingDate !== null) {
            headers.set('startingDate', String(startingDate));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getRequiredUpdatesWithHttpInfo(mac, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getRequiredUpdates/${mac}'
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getRequiredUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    getSoftwareToRestartWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/getSoftwareToRestart/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getSoftwareToRestart.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDeviceFileUpdatesWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listDeviceFileUpdates/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceFileUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDeviceInstalledSoftwaresWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listDeviceInstalledSoftwares/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceInstalledSoftwares.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevicePendingInstallSoftwaresWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listDevicePendingInstallSoftwares/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDevicePendingInstallSoftwares.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevicePendingLogRequestsWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listDevicePendingLogRequests/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDevicePendingLogRequests.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    listDeviceSettingsWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listDeviceSettings/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listDeviceSettings.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param serial
     * @param mac
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevicesWithHttpInfo(authenticationKey, body, serial, mac, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listDevices';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (serial !== undefined && serial !== null) {
            headers.set('serial', String(serial));
        }
        if (mac !== undefined && mac !== null) {
            headers.set('mac', String(mac));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listFileUpdatesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listFileUpdates';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listSoftwaresWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listSoftwares';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listUpdateBundleWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listBundles';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listUpdateFilesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/listUpdateFiles';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    massDownloadWithHttpInfo(authenticationKey, body, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/massDownload';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    prepareFileResourceBundleWithHttpInfo(authenticationKey, body, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/prepareFileResourceBundle';
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param mac
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param serialNumber
     * @param body
     */
    registerWithHttpInfo(mac, authenticationKey, serialNumber, body, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/register/${mac}'
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling register.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (serialNumber !== undefined && serialNumber !== null) {
            headers.set('serialNumber', String(serialNumber));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param filter
     * @param level
     * @param interval
     * @param startMilis
     */
    requestLogWithHttpInfo(deviceId, authenticationKey, filter, level, interval, startMilis, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/requestLog/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling requestLog.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (filter !== undefined && filter !== null) {
            headers.set('filter', String(filter));
        }
        if (level !== undefined && level !== null) {
            headers.set('level', String(level));
        }
        if (interval !== undefined && interval !== null) {
            headers.set('interval', String(interval));
        }
        if (startMilis !== undefined && startMilis !== null) {
            headers.set('startMilis', String(startMilis));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param softwareId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    setSoftwareToRestartWithHttpInfo(deviceId, softwareId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/setSoftwareToRestart/${deviceId}/${softwareId}'
            .replace('${' + 'deviceId' + '}', String(deviceId))
            .replace('${' + 'softwareId' + '}', String(softwareId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling setSoftwareToRestart.');
        }
        // verify required parameter 'softwareId' is not null or undefined
        if (softwareId === null || softwareId === undefined) {
            throw new Error('Required parameter softwareId was null or undefined when calling setSoftwareToRestart.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param serialNumber
     */
    updateDeviceStatusAndGetIsActivateWithHttpInfo(id, authenticationKey, body, serialNumber, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateDeviceStatusAndGetIsActivate/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDeviceStatusAndGetIsActivate.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (serialNumber !== undefined && serialNumber !== null) {
            headers.set('serialNumber', String(serialNumber));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param requestId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    updateFileUpdateStartedWithHttpInfo(requestId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateFileUpdateStarted/${requestId}'
            .replace('${' + 'requestId' + '}', String(requestId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling updateFileUpdateStarted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    updateMultipleSoftwareWithHttpInfo(deviceId, authenticationKey, body, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateMultipleSoftware/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateMultipleSoftware.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param requestId
     * @param fileResourceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param logDate
     */
    updateRequestLogAsCompletedWithHttpInfo(requestId, fileResourceId, authenticationKey, logDate, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateRequestLogAsCompleted/${requestId}/${fileResourceId}'
            .replace('${' + 'requestId' + '}', String(requestId))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling updateRequestLogAsCompleted.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling updateRequestLogAsCompleted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (logDate !== undefined && logDate !== null) {
            headers.set('logDate', String(logDate));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param requestId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted
     */
    updateRequestLogAsGatheredWithHttpInfo(requestId, authenticationKey, dateCompleted, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateRequestLogAsStarted/${requestId}'
            .replace('${' + 'requestId' + '}', String(requestId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling updateRequestLogAsGathered.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param softwareId
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateSoftwareWithHttpInfo(softwareId, deviceId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateSoftware/${softwareId}/${deviceId}'
            .replace('${' + 'softwareId' + '}', String(softwareId))
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'softwareId' is not null or undefined
        if (softwareId === null || softwareId === undefined) {
            throw new Error('Required parameter softwareId was null or undefined when calling updateSoftware.');
        }
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateSoftware.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param bundleId
     * @param deviceId
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateSoftwareBundleWithHttpInfo(bundleId, deviceId, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateSoftwareBundle/${bundleId}/${deviceId}'
            .replace('${' + 'bundleId' + '}', String(bundleId))
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'bundleId' is not null or undefined
        if (bundleId === null || bundleId === undefined) {
            throw new Error('Required parameter bundleId was null or undefined when calling updateSoftwareBundle.');
        }
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateSoftwareBundle.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateUpdateCompletedWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateUpdateCompleted/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUpdateCompleted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateUpdateStartedWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateUpdateStarted/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUpdateStarted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
    /**
     *
     *
     * @param id
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    updateUpdateVerifiedWithHttpInfo(id, authenticationKey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/softwareUpdate/updateUpdateVerified/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new http_1.URLSearchParams();
        let headers = new http_1.Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUpdateVerified.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new http_2.RequestOptions({
            method: http_2.RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.http.request(path, requestOptions);
    }
};
SoftwareUpdateService = __decorate([
    core_1.Injectable(),
    __param(1, core_1.Optional()), __param(1, core_1.Inject(variables_1.BASE_PATH)), __param(2, core_1.Optional())
], SoftwareUpdateService);
exports.SoftwareUpdateService = SoftwareUpdateService;
//# sourceMappingURL=softwareUpdate.service.js.map